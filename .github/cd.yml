name: CD (main)

on:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

concurrency:
  group: cd-main
  cancel-in-progress: false

env:
  TF_DIR: infra/envs/dev
  AWS_REGION: us-east-1

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 25
    env:
      TF_IN_AUTOMATION: "true"
      TF_INPUT: "false"
      TF_CLI_ARGS: "-lock-timeout=5m"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS via OIDC
        if: ${{ secrets.AWS_ROLE_TO_ASSUME != '' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}

      - name: Configure AWS credentials (fallback)
        if: ${{ secrets.AWS_ROLE_TO_ASSUME == '' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Which auth path?
        run: echo "Using ${{ secrets.AWS_ROLE_TO_ASSUME != '' && 'OIDC' || 'STATIC KEYS' }}"

      - name: Verify AWS identity
        run: aws sts get-caller-identity

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: Terraform Init
        working-directory: ${{ env.TF_DIR }}
        run: terraform init -input=false

      - name: Select/Create Workspace (dev)
        working-directory: ${{ env.TF_DIR }}
        run: terraform workspace select dev || terraform workspace new dev

      - name: Validate security configuration in Terraform
        working-directory: ${{ env.TF_DIR }}
        run: |
          set -e
          FILE=$(git ls-files '../../modules/**/main.tf' | head -n1 || true)
          if [ -z "$FILE" ]; then
            echo "Could not find ECS module main.tf; skipping check"
            exit 0
          fi
          if grep -Eq 'stopTimeout.*5' "$FILE" && grep -Eq 'VALIDATOR_TIMEOUT_SEC.*5' "$FILE"; then
            echo "ECS security configuration found"
          else
            echo "Missing security configuration in ECS module ($FILE)"
            exit 1
          fi

      - name: Terraform Validate
        working-directory: ${{ env.TF_DIR }}
        run: terraform validate

      - name: Terraform Plan
        working-directory: ${{ env.TF_DIR }}
        run: terraform plan -out=tfplan -input=false

      - name: Terraform Apply
        working-directory: ${{ env.TF_DIR }}
        run: terraform apply -auto-approve tfplan

      - name: Read validator URL
        id: tfout
        working-directory: ${{ env.TF_DIR }}
        run: |
          URL=$(terraform output -raw validator_service_url 2>/dev/null || true)
          if [ -z "$URL" ]; then
            URL="${{ secrets.PUBLIC_BASE_URL }}"
          fi
          echo "validator_url=$URL" >> "$GITHUB_OUTPUT"

      - name: Echo service URL
        run: echo "URL=${{ steps.tfout.outputs.validator_url }}"

      - name: Post-deploy smoke
        run: |
          URL="${{ steps.tfout.outputs.validator_url }}"
          if [ -z "$URL" ]; then
            echo "No URL found (terraform output or PUBLIC_BASE_URL). Skipping smoke."
            exit 0
          fi
          echo "Probing $URL/health ..."
          code=""
          for i in {1..10}; do
            code=$(curl -s -o /dev/null -w "%{http_code}" "$URL/health" || true)
            if [ "$code" = "200" ]; then
              echo "Smoke OK"
              exit 0
            fi
            echo "Waiting for service... ($i/10) - HTTP $code"
            sleep 6
          done
          echo "Smoke failed for $URL/health (last code: $code)"
          exit 1

      - name: Validate DoS protection in deployed service
        run: |
          URL="${{ steps.tfout.outputs.validator_url }}"
          echo "Testing rate limiting on $URL/validate ..."
          RATE_LIMIT_HIT=false
          SUCCESS_COUNT=0
          for i in {1..25}; do
            HTTP_CODE=$(curl -s -w "%{http_code}" -X POST "$URL/validate" \
              -H "Content-Type: application/json" \
              -d '{"pkgName":"demo","version":"1.0.0","userId":"test","groups":["Group_106"]}' \
              -o /dev/null --max-time 10 --connect-timeout 5)
            echo "Request $i: HTTP $HTTP_CODE"
            if [ "$HTTP_CODE" = "200" ]; then
              SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
            elif [ "$HTTP_CODE" = "429" ]; then
              RATE_LIMIT_HIT=true
              echo "Rate limiting triggered at request $i"
              break
            fi
          done
          if [ "$RATE_LIMIT_HIT" = "true" ]; then
            echo "Rate limiting is working"
          elif [ $SUCCESS_COUNT -gt 20 ]; then
            echo "Rate limiting NOT working (>$SUCCESS_COUNT successful requests)"
            exit 1
          else
            echo "Test inconclusive (responses not 200/429)."
          fi
